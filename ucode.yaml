# Microcode RAM data description
#
# Copyright (c) 2024 David Hunter
#
# This program is GPL licensed. See COPYING for the full license.

types:
  - name: e_uaddr
    desc: ucode address
    type: enum
    width: 8
    prefix: UA_
    # values will come from the rows list

  - name: e_ubm
    desc: branch mode
    type: enum
    width: 2
    prefix: UBM_
    values:
      - ADV                     # advance (default)
      - END                     # return to IDLE
      - DA                      # direct address

  - name: e_mcy
    desc: machine cycle
    type: enum
    width: 2
    prefix: UTX_
    values:
      - T1
      - T2
      - T3
      - T4

  - name: e_urfs
    desc: register file select
    type: enum
    width: 4
    prefix: URFS_
    values:
      - V
      - A
      - B
      - C
      - D
      - E
      - H
      - L
      - SPL
      - SPH
      - PCL
      - PCH
      - IR210                   # IR[2:0] encodes V,A,B...L
      - W                       # working address

  - name: e_idbs
    desc: idb select
    type: enum
    width: 3
    prefix: UIDBS_
    values:
      - 0                       # zero
      - RF                      # register file: A, B, etc.
      - DB                      # external data bus
      - JRL                     # sign-ext. IR[5:0] (for JR)
      - JRH                     # sign-ext. IR[5] (for JR)
      - CO                      # ALU output
      - SPR                     # special reg.
      - CALT                    # EA for CALT

  - name: e_lts
    desc: load target select
    type: enum
    width: 4
    prefix: ULTS_
    values:
      - NONE                    # (default) no load
      - RF
      - DOR
      - AI
      - BI
      - IE
      - SPR                     # special reg.

  - name: e_abs
    desc: ab select
    type: enum
    width: 3
    prefix: UABS_
    values:
      - PC                      # (default)
      - SP
      - BC
      - DE
      - HL
      - VW
      - IDB_W
      - IR10                    # IR[1:0] encodes BC, DE, HL

  - name: e_sprs
    desc: special register select
    type: enum
    width: 1
    prefix: USRS_
    values:
      - IR2                     # IR[2:0]
      - IR3                     # IR[3:0]

  - name: e_aluop
    desc: ALU operation
    type: enum
    width: 4
    prefix: UAO_
    values:
      - NOP
      - SUM
      - INC
      - DEC
      - OR
      - AND
      - EOR
      - ASL
      - ROL
      - LSR
      - ROR

  - name: e_cis
    desc: ALU carry in select
    type: enum
    width: 2
    prefix: UCIS_
    values:
      - 0
      - 1
      - CCO
      - PSW_CY

  - name: e_sks
    desc: SKip flag source
    type: enum
    width: 3
    prefix: USKS_
    values:
      - 0                       # (default) reset
      - 1                       # set (for RETS)
      - C
      - NC
      - Z
      - NZ


# Instruction decode LUT (ird_lut) structure
# LUT rows populated by rows with 'at' fields
columns_ird:
  - name: addr
    type: e_uaddr
    desc: microcode entry point
  - name: m1_overlap
    width: 1
    desc: New M1 starts immediately
  - name: skipn
    width: 2
    desc: Number of operands to skip when ins. is skipped


# Microcode RAM structure
columns:
  - name: bm
    type: e_ubm
    desc: branch mode
  - name: nua
    type: e_uaddr
    desc: next address
  - name: idx
    width: 3
    desc: general-purpose data
  - name: rfos
    type: e_urfs
    desc: register file output select -> idb
  - name: rfts
    type: e_urfs
    desc: register file target select
  - name: idbs
    type: e_idbs
    desc: idb select
  - name: lts
    type: e_lts
    desc: load target select
  - name: abs
    type: e_abs
    desc: ab select
  - name: abits
    type: e_abs
    desc: abi target select
  - name: m1
    width: 1
    desc: Fetch next opcode (start M1)
  - name: pc_inc
    width: 1
    desc: increment PC
  - name: ab_inc
    width: 1
    desc: increment ab
  - name: ab_dec
    width: 1
    desc: decrement ab
  - name: aout
    width: 1
    desc: ab -> AOR
  - name: load
    width: 1
    desc: assert RDB (read operation)
  - name: store
    width: 1
    desc: dor -> DB
  - name: aluop
    type: e_aluop
    desc: ALU operation
  - name: cis
    type: e_cis
    desc: ALU carry in select
  - name: bi0
    width: 1
    desc: Zero BI
  - name: bin
    width: 1
    desc: Negate BI
  - name: pswz
    width: 1
    desc: (CO == 0) -> PSW.Z
  - name: pswcy
    width: 1
    desc: CCO -> PSW.CY
  - name: pswhc
    width: 1
    desc: CHO -> PSW.HC
  - name: pswsk
    type: e_sks
    desc: PSW.SK source


rows:
  - addr: IDLE
    bm: DA
    nua: IDLE

    # Idle cycles for skipping instructions w/ 1-2 operands
  - addr: SKIP_OP2_T1
    aout: 1
    pc_inc: 1
  - addr: SKIP_OP2_T2
    load: 1
  - addr: SKIP_OP2_T3
  - addr: SKIP_OP1_T1
    aout: 1
    pc_inc: 1
  - addr: SKIP_OP1_T2
    load: 1
  - addr: SKIP_OP1_T3
    m1: 1
    bm: END

  - addr: DI
    at: 0x124                   # prefix 0x48
    m1_overlap: 1
    idx: 0
    lts: IE
    bm: END

  - addr: EI
    at: 0x120                   # prefix 0x48
    m1_overlap: 1
    idx: 1
    lts: IE
    bm: END

  - addr: JR_C1_T1
    at: [ 0xC0, 0xFF ]
    # PCL -> idb -> AI
    rfos: PCL
    idbs: RF
    lts: AI
  - addr: JR_C1_T2
    # IR[5:0] -> idb -> BI
    idbs: JRL
    lts: BI
  - addr: JR_C1_T3
    # AI + BI -> CO
    aluop: SUM
    cis: 0
  - addr: JR_C2_T1
    # CO -> idb -> PCL
    idbs: CO
    lts: RF
    rfts: PCL
  - addr: JR_C2_T2
    # PCH -> idb -> AI
    rfos: PCH
    idbs: RF
    lts: AI
  - addr: JR_C2_T3
    # sign-ext. IR[5] -> idb -> BI
    idbs: JRH
    lts: BI
  - addr: JR_C3_T1
    # AI + BI + CCO -> CO
    aluop: SUM
    cis: CCO
  - addr: JR_C3_T2
    # CO -> idb -> PCH
    idbs: CO
    lts: RF
    rfts: PCH
  - addr: JR_C3_T3
    bm: END
    m1: 1

  - addr: JRE_C1_T1
    at: 0x4E                    # JRE +jdisp
    # Fetch jdisp
    aout: 1
    pc_inc: 1
  - addr: JRE_C1_T2
    # PCL -> idb -> AI
    rfos: PCL
    idbs: RF
    lts: AI
    load: 1
  - addr: JRE_C1_T3
    # DB -> idb -> BI
    idbs: DB
    lts: BI
    # AI + BI -> CO
    aluop: SUM
    cis: 0
  - addr: JRE_C2_T1
    # CO -> idb -> PCL
    idbs: CO
    lts: RF
    rfts: PCL
  - addr: JRE_C2_T2
    # PCH -> idb -> AI, 0 -> BI
    rfos: PCH
    idbs: RF
    lts: AI
    bi0: 1
    # AI + BI + CCO -> CO
    aluop: SUM
    cis: CCO
  - addr: JRE_C2_T3
    # CO -> idb -> PCH
    idbs: CO
    lts: RF
    rfts: PCH
    bm: END
    m1: 1

    # LXI SP, bbaa
  - addr: LXI_SP_C1_T1
    at: 0x04
    skipn: 2
    aout: 1
  - addr: LXI_SP_C1_T2
    load: 1
  - addr: LXI_SP_C1_T3
    # DB -> idb -> SPL
    idbs: DB
    rfts: SPL
    lts: RF
    pc_inc: 1
  - addr: LXI_SP_C2_T1
    aout: 1
  - addr: LXI_SP_C2_T2
    load: 1
  - addr: LXI_SP_C2_T3
    # DB -> idb -> SPH
    idbs: DB
    rfts: SPH
    lts: RF
    pc_inc: 1
    bm: END
    m1: 1

  - addr: LXI_B_C1_T1
    at: 0x14                    # LXI BC, bbaa
    skipn: 2
    aout: 1
  - addr: LXI_B_C1_T2
    load: 1
  - addr: LXI_B_C1_T3
    # DB -> idb -> C
    idbs: DB
    rfts: C
    lts: RF
    pc_inc: 1
  - addr: LXI_B_C2_T1
    aout: 1
  - addr: LXI_B_C2_T2
    load: 1
  - addr: LXI_B_C2_T3
    # DB -> idb -> B
    idbs: DB
    rfts: B
    lts: RF
    pc_inc: 1
    bm: END
    m1: 1

    # LXI DE, bbaa
  - addr: LXI_D_C1_T1
    at: 0x24
    skipn: 2
    aout: 1
  - addr: LXI_D_C1_T2
    load: 1
  - addr: LXI_D_C1_T3
    # DB -> idb -> E
    idbs: DB
    rfts: E
    lts: RF
    pc_inc: 1
  - addr: LXI_D_C2_T1
    aout: 1
  - addr: LXI_D_C2_T2
    load: 1
  - addr: LXI_D_C2_T3
    # DB -> idb -> D
    idbs: DB
    rfts: D
    lts: RF
    pc_inc: 1
    bm: END
    m1: 1

  - addr: LXI_H_C1_T1
    at: 0x34                    # LXI HL, bbaa
    skipn: 2
    aout: 1
  - addr: LXI_H_C1_T2
    load: 1
  - addr: LXI_H_C1_T3
    # DB -> idb -> L
    idbs: DB
    rfts: L
    lts: RF
    pc_inc: 1
  - addr: LXI_H_C2_T1
    aout: 1
  - addr: LXI_H_C2_T2
    load: 1
  - addr: LXI_H_C2_T3
    # DB -> idb -> H
    idbs: DB
    rfts: H
    lts: RF
    pc_inc: 1
    bm: END
    m1: 1

  - addr: DCR_B_C1_T1
    at: 0x52                    # DCR B
    m1_overlap: 1
    # B -> idb -> AI, AI - 1 -> CO
    rfos: B
    idbs: RF
    lts: AI
    aluop: DEC
  - addr: DCR_B_C1_T2
    # CO -> idb -> B
    rfts: B
    idbs: CO
    lts: RF
    pswz: 1                     # Update PSW.Z
    pswhc: 1                    # Update PSW.HC
    pswsk: NC                   # !CCO -> PSW.SK
    bm: END

  - addr: DCR_C_C1_T1
    at: 0x53                    # DCR C
    m1_overlap: 1
    # C -> idb -> AI, AI - 1 -> CO
    rfos: C
    idbs: RF
    lts: AI
    aluop: DEC
  - addr: DCR_C_C1_T2
    # CO -> idb -> C
    rfts: C
    idbs: CO
    lts: RF
    pswz: 1                     # Update PSW.Z
    pswhc: 1                    # Update PSW.HC
    pswsk: NC                   # !CCO -> PSW.SK
    bm: END

  - addr: MVI_IMM_C1_T1
    at: [ 0x68, 0x6F ]          # MVI r, byte
    skipn: 1
    aout: 1
  - addr: MVI_IMM_C1_T2
    load: 1
  - addr: MVI_IMM_C1_T3
    # DB -> idb -> r
    idbs: DB
    rfts: IR210
    lts: RF
    pc_inc: 1
    bm: END
    m1: 1

  - addr: MOV_SR_A_C1_T1
    at: [ 0x3C0, 0x3FF ]        # MOV sr, A
    # A -> idb -> spr
    rfos: A
    idbs: RF
    lts: SPR
    sprs: IR3
  - addr: MOV_SR_A_C1_T2
  - addr: MOV_SR_A_C1_T3
    bm: END
    m1: 1

  - addr: STAX_H_C1_T1
    at: 0x3b                    # STAX H
    # HL -> ab -> aor
    abs: HL
    aout: 1
    # A -> idb -> dor
    rfos: A
    idbs: RF
    lts: DOR
  - addr: STAX_H_C1_T2
    # dor -> DB
    store: 1
  - addr: STAX_H_C1_T3
    m1: 1
    bm: END

  - addr: STAX_HP_C1_T1
    at: 0x3d                    # STAX H+
    # HL -> ab -> aor
    abs: HL
    aout: 1
    # A -> idb -> dor
    rfos: A
    idbs: RF
    lts: DOR
  - addr: STAX_HP_C1_T2
    # dor -> DB
    store: 1
    # HL + 1 -> HL
    abs: HL
    ab_inc: 1
    abits: HL
  - addr: STAX_HP_C1_T3
    m1: 1
    bm: END

  - addr: STAW_C1_T1
    at: 0x38                    # STAW wa
    skipn: 1
    aout: 1
  - addr: STAW_C1_T2
    load: 1
  - addr: STAW_C1_T3
    # DB -> idb -> W
    idbs: DB
    rfts: W
    lts: RF
    pc_inc: 1
  - addr: STAW_C2_T1
    # A -> idb -> dor
    rfos: A
    idbs: RF
    lts: DOR
    # VW -> ab -> aor
    abs: VW
    aout: 1
  - addr: STAW_C2_T2
    # dor -> DB
    store: 1
  - addr: STAW_C2_T3
    m1: 1
    bm: END

    # ORI sr2, byte
  - addr: ORI_SR_IMM_C1_T1
    at: [ 0x598, 0x59f ]        # prefix 0x64
    skipn: 1
    aout: 1
  - addr: ORI_SR_IMM_C1_T2
    load: 1
  - addr: ORI_SR_IMM_C1_T3
    # DB -> idb -> BI
    idbs: DB
    lts: BI
    pc_inc: 1
  - addr: ORI_SR_IMM_C2_T1
  - addr: ORI_SR_IMM_C2_T2
  - addr: ORI_SR_IMM_C2_T3
    # spr -> idb -> AI
    sprs: IR2
    idbs: SPR
  - addr: ORI_SR_IMM_C3_T1
  - addr: ORI_SR_IMM_C3_T2
  - addr: ORI_SR_IMM_C3_T3
    # AI | BI -> CO
    aluop: OR
  - addr: ORI_SR_IMM_C4_T1
  - addr: ORI_SR_IMM_C4_T2
  - addr: ORI_SR_IMM_C4_T3
    # CO -> idb -> spr
    idbs: CO
    lts: SPR
    sprs: IR2
    m1: 1
    bm: END

    # BLOCK: (DE)+ <- (HL)+, C <- C - 1, end if borrow
  - addr: BLOCK_C1_T1
    at: 0x31
    # HL -> ab -> aor
    abs: HL
    aout: 1
  - addr: BLOCK_C1_T2
    # HL + 1 -> HL
    abs: HL
    ab_inc: 1
    abits: HL
    load: 1
  - addr: BLOCK_C1_T3
    # DB -> idb -> W
    idbs: DB
    rfts: W
    lts: RF
  - addr: BLOCK_C2_T1
    # W -> idb -> dor
    rfos: W
    idbs: RF
    lts: DOR
    # DE -> ab -> aor
    abs: DE
    aout: 1
  - addr: BLOCK_C2_T2
    # dor -> DB
    store: 1
    # DE + 1 -> DE
    abs: DE
    ab_inc: 1
    abits: DE
  - addr: BLOCK_C2_T3
  - addr: BLOCK_C3_T1
    # C -> idb -> AI, AI - 1 -> CO
    rfos: C
    idbs: RF
    lts: AI
    aluop: DEC
  - addr: BLOCK_C3_T2
    # CO -> idb -> C
    rfts: C
    idbs: CO
    lts: RF
  - addr: BLOCK_C3_T3
    pswsk: NC                   # !CCO -> PSW.SK
    abs: PC
    ab_dec: 1                   # repeat ins. until skipped
    m1: 1
    bm: END

    # JMP word
  - addr: JMP_C1_T1
    at: 0x54
    skipn: 2
    # Fetch word lo
    aout: 1
    pc_inc: 1
  - addr: JMP_C1_T2
    load: 1
  - addr: JMP_C1_T3
    # DB -> idb -> W
    idbs: DB
    rfts: W
    lts: RF
  - addr: JMP_C2_T1
    # Fetch word hi
    aout: 1
  - addr: JMP_C2_T2
    # W -> idb -> PCL
    rfos: W
    idbs: RF
    lts: RF
    rfts: PCL
    load: 1
  - addr: JMP_C2_T3
    # DB -> idb -> PCH
    idbs: DB
    lts: RF
    rfts: PCH
    bm: END
    m1: 1

    # MOV r, word (Move Memory to Register)
  - addr: MOV_ABS_C1_T1
    at: [ 0x668, 0x66f ]        # prefix 0x70
    skipn: 2
    # Fetch word lo
    aout: 1
    pc_inc: 1
  - addr: MOV_ABS_C1_T2
    load: 1
  - addr: MOV_ABS_C1_T3
    # DB -> idb -> W
    idbs: DB
    rfts: W
    lts: RF
  - addr: MOV_ABS_C2_T1
    # Fetch word hi
    aout: 1
    pc_inc: 1
  - addr: MOV_ABS_C2_T2
    load: 1
  - addr: MOV_ABS_C2_T3
    # DB -> idb -> AI, 0 -> BI
    idbs: DB
    lts: AI
    bi0: 1
    # AI + BI -> CO
    aluop: SUM
  - addr: MOV_ABS_C3_T1
    # W -> abl -> aorl, CO -> idb -> abh -> aorh
    idbs: CO
    abs: IDB_W
    aout: 1
  - addr: MOV_ABS_C3_T2
    load: 1
  - addr: MOV_ABS_C3_T3
    # DB -> idb -> r
    idbs: DB
    rfts: IR210
    lts: RF
    bm: END
    m1: 1

    # NEI A, byte (Not Equal Immediate with A)
  - addr: NEI_IMM_A_C1_T1
    at: 0x67
    # Fetch byte
    aout: 1
    pc_inc: 1
  - addr: NEI_IMM_A_C1_T2
    # A -> idb -> AI
    rfos: A
    idbs: RF
    lts: AI
    load: 1
  - addr: NEI_IMM_A_C1_T3
    # DB -> idb -> BI
    idbs: DB
    lts: BI
    # AI - BI -> CO
    aluop: SUM
    bin: 1
    cis: 1
    m1: 1
  - addr: NEI_IMM_A_C2_T1
    idbs: CO
    pswz: 1                     # Update PSW.Z
    pswcy: 1                    # Update PSW.CY
    pswhc: 1                    # Update PSW.HC
    pswsk: NZ                   # Update PSW.SK
    bm: END

    # MVIX rpa1, byte (Move Imm. to Memory address by Reg Pair)
  - addr: MVIX_IMM_C1_T1
    at: [ 0x48, 0x4b ]
    skipn: 1
    # Fetch byte
    aout: 1
    pc_inc: 1
  - addr: MVIX_IMM_C1_T2
    load: 1
  - addr: MVIX_IMM_C1_T3
    # DB -> idb -> W
    idbs: DB
    rfts: W
    lts: RF
  - addr: MVIX_IMM_C2_T1
    # W -> idb -> dor
    rfos: W
    idbs: RF
    lts: DOR
    # DE -> ab -> aor
    abs: IR10
    aout: 1
  - addr: MVIX_IMM_C2_T2
    # dor -> DB
    store: 1
  - addr: MVIX_IMM_C2_T3
    m1: 1
    bm: END

    # CALT (Call Table Address)
  - addr: CALT_C1_T1            # SP <- SP-1
    at: [ 0x80, 0xBF ]
    # IR[5:0] -> idb -> AI
    idbs: JRL
    lts: AI
  - addr: CALT_C1_T2
  - addr: CALT_C1_T3
    # SP - 1 -> SP
    abs: SP
    ab_dec: 1
    abits: SP
  - addr: CALT_C2_T1            # (SP) <- PCH, SP <- SP-1
    # PCH -> idb -> dor
    rfos: PCH
    idbs: RF
    lts: DOR
    # SP -> ab -> aor
    abs: SP
    aout: 1
  - addr: CALT_C2_T2
    # dor -> DB
    store: 1
  - addr: CALT_C2_T3
    # SP - 1 -> SP
    abs: SP
    ab_dec: 1
    abits: SP
  - addr: CALT_C3_T1            # (SP) <- PCL
    # PCL -> idb -> dor
    rfos: PCL
    idbs: RF
    lts: DOR
    # SP -> ab -> aor
    abs: SP
    aout: 1
  - addr: CALT_C3_T2
    # dor -> DB
    store: 1
  - addr: CALT_C3_T3
    # effective addr lo. -> idb -> W
    idx: 0
    idbs: CALT
    lts: RF
    rfts: W
  - addr: CALT_C4_T1            # PCL <- (128 + 2ta)
    # W -> abl -> aorl, 0 -> idb -> abh -> aorh
    idbs: 0
    abs: IDB_W
    aout: 1
  - addr: CALT_C4_T2
    load: 1
    # effective addr hi. -> idb -> W
    idx: 1
    idbs: CALT
    lts: RF
    rfts: W
  - addr: CALT_C4_T3
    # DB -> idb -> PCL
    idbs: DB
    lts: RF
    rfts: PCL
  - addr: CALT_C5_T1            # PCH <- (129 + 2ta)
    # W -> abl -> aorl, 0 -> idb -> abh -> aorh
    idbs: 0
    abs: IDB_W
    aout: 1
  - addr: CALT_C5_T2
    load: 1
  - addr: CALT_C5_T3
    # DB -> idb -> PCH
    idbs: DB
    lts: RF
    rfts: PCH
    m1: 1
    bm: END
