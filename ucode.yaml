# Microcode / nanocode ROM data description
#
# Copyright (c) 2024 David Hunter
#
# This program is GPL licensed. See COPYING for the full license.

types:
  - name: e_uaddr
    desc: ucode address
    type: enum
    width: 9
    prefix: UA_
    # values will come from the ucode.rows list

  - name: e_naddr
    desc: ncode address
    type: enum
    width: 8
    prefix: NA_
    # values will come from the ncode.rows list

  - name: e_ubm
    desc: branch mode
    type: enum
    width: 2
    prefix: UBM_
    values:
      - ADV                     # advance (default)
      - END                     # return to IDLE
      - DA                      # direct address

  - name: e_mcy
    desc: machine cycle
    type: enum
    width: 2
    prefix: UTX_
    values:
      - T1
      - T2
      - T3
      - T4

  - name: e_urfs
    desc: register file select
    type: enum
    width: 4
    prefix: URFS_
    values:
      - V
      - A
      - B
      - C
      - D
      - E
      - H
      - L
      - PSW
      - SPL
      - SPH
      - PCL
      - PCH
      - IR210                   # IR[2:0] encodes V,A,B...L
      - W                       # working address

  - name: e_idbs
    desc: idb select
    type: enum
    width: 3
    prefix: UIDBS_
    values:
      - 0                       # zero
      - RF                      # register file: A, B, etc.
      - DB                      # external data bus
      - CO                      # ALU output
      - SPR                     # special reg.
      - SDG                     # special data generator

  - name: e_lts
    desc: load target select
    type: enum
    width: 4
    prefix: ULTS_
    values:
      - NONE                    # (default) no load
      - RF
      - DOR
      - AI
      - BI
      - IE
      - SPR                     # special reg.

  - name: e_abs
    desc: ab select
    type: enum
    width: 3
    prefix: UABS_
    values:
      - PC                      # (default)
      - SP
      - BC
      - DE
      - HL
      - VW
      - IDB_W
      - IR10                    # IR[1:0] encodes BC, DE, HL

  - name: e_spr
    desc: special register
    type: enum
    width: 4
    prefix: USPR_
    values:
      - PA                      # Port A
      - PB                      # Port B
      - PC                      # Port C
      - MK                      # Interrupt Mask
      - MB                      # Mode B
      - MC                      # Mode C
      - TM0                     # Timer Reg 0
      - TM1                     # Timer Reg 1
      - S                       # Serial Reg
      - TMM                     # Timer Mode Reg

  - name: e_sprs
    desc: special register select
    type: enum
    width: 1
    prefix: USRS_
    values:
      - IR2                     # IR[2:0]
      - IR3                     # IR[3:0]

  - name: e_sdgs
    desc: special data generator select
    type: enum
    width: 2
    prefix: USDGS_
    values:
      - JRL                     # sign-ext. IR[5:0] (for JR)
      - JRH                     # sign-ext. IR[5] (for JR)
      - CALT                    # EA for CALT
      - INTVA                   # EA for interrupt vector

  - name: e_aluop
    desc: ALU operation
    type: enum
    width: 4
    prefix: UAO_
    values:
      - NOP
      - SUM
      - INC
      - DEC
      - OR
      - AND
      - EOR
      - LSL
      - ROL
      - LSR
      - ROR

  - name: e_cis
    desc: ALU carry in select
    type: enum
    width: 2
    prefix: UCIS_
    values:
      - 0
      - 1
      - CCO
      - PSW_CY

  - name: e_sks
    desc: SKip flag source
    type: enum
    width: 3
    prefix: USKS_
    values:
      - 0                       # (default) reset
      - 1                       # set (for RETS)
      - C
      - NC
      - Z
      - NZ
      - I                       # INT*F set
      - NI                      # INT*F clear


######################################################################
# Instruction decode LUT (ird_lut)
ird:
  columns:
    - name: uaddr
      type: e_uaddr
      desc: microcode entry point
    - name: m1_overlap
      width: 1
      desc: New M1 starts immediately
    - name: skipn
      width: 2
      desc: Number of operands to skip when ins. is skipped

  rows:
    # no prefix opcode

    - at: 0x00                  # NOP
      uaddr: IDLE
      m1_overlap: 1
    - at: 0x04                  # LXI SP, bbaa
      uaddr: LDX_IMM_SP
      skipn: 2
    - at: 0x08                  # RET
      uaddr: RET
    - at: [ 0x0a, 0x0f ]        # MOV A, r1
      uaddr: MOV_A_R1
      m1_overlap: 1
    - at: 0x14                  # LXI BC, bbaa
      uaddr: LDX_IMM_B
      skipn: 2
    - at: 0x19                  # STM
      uaddr: STM
      m1_overlap: 1
    - at: [ 0x1a, 0x1f ]        # MOV r1, A
      uaddr: MOV_R1_A
      m1_overlap: 1
    - at: 0x20                  # INRW wa
      uaddr: INRW
      skipn: 1
    - at: 0x24                  # LXI DE, bbaa
      uaddr: LDX_IMM_D
      skipn: 2
    - at: 0x26                  # ADINC A, byte
      uaddr: ADDNC_A_IMM
      skipn: 1
    - at: 0x27                  # GTI A, byte
      uaddr: GT_A_IMM
    - at: 0x28                  # LDAW wa
      uaddr: LDW_A
      skipn: 1
    - at: 0x2b                  # LDAX H
      uaddr: LDX_A_H
    - at: 0x2d                  # LDAX H+
      uaddr: LDX_A_HP
    - at: 0x30                  # DCRW wa
      uaddr: DCRW
      skipn: 1
    - at: 0x31                  # BLOCK
      uaddr: BLOCK
    - at: 0x34                  # LXI HL, bbaa
      uaddr: LDX_IMM_H
      skipn: 2
    - at: 0x36                  # SUINB A, byte
      uaddr: SUBNB_A_IMM
      skipn: 1
    - at: 0x37                  # LTI A, byte
      uaddr: LT_A_IMM
    - at: 0x38                  # STAW wa
      uaddr: STAW
      skipn: 1
    - at: 0x3a                  # STAX D
      uaddr: STAX_D
    - at: 0x3b                  # STAX H
      uaddr: STAX_H
    - at: 0x3c                  # STAX D+
      uaddr: STAX_DP
    - at: 0x3d                  # STAX H+
      uaddr: STAX_HP
    - at: [ 0x41, 0x43 ]        # INR r2
      uaddr: INR
      m1_overlap: 1
    - at: 0x46                  # ADI A, byte
      uaddr: ADD_A_IMM
      skipn: 1
    - at: 0x47                  # ONI A, byte
      uaddr: ON_A_IMM
    - at: [ 0x48, 0x4b ]        # MVIX rpa1, byte
      uaddr: MOVX_IMM
      skipn: 1
    - at: 0x4E                  # JRE +jdisp
      uaddr: JRE
      skipn: 1
    - at: [ 0x51, 0x53 ]        # DCR r2
      uaddr: DCR
      m1_overlap: 1
    - at: 0x54                  # JMP word
      uaddr: JMP
      skipn: 2
    - at: 0x57                  # OFFI A, byte
      uaddr: OFF_A_IMM
    - at: 0x62                  # RETI
      uaddr: RETI
    - at: 0x66                  # SUI A, byte
      uaddr: SUB_A_IMM
      skipn: 1
    - at: 0x67                  # NEI A, byte
      uaddr: NE_A_IMM
    - at: [ 0x68, 0x6F ]        # MVI r, byte
      uaddr: MOV_IMM
      skipn: 1
    - at: 0x71                  # MVIW
      uaddr: MOVW_IMM
      skipn: 2
    - at: 0x72                  # SOFTI
      uaddr: INT
    - at: 0x77                  # EQI A, byte
      uaddr: EQ_A_IMM
    - at: [ 0x80, 0xBF ]        # CALT
      uaddr: CALT
    - at: [ 0xC0, 0xFF ]        # JR
      uaddr: JR

    # 0x1xx: prefix 0x48
    - at: [ 0x100, 0x104 ]      # SKIT irf
      uaddr: SKIT
      m1_overlap: 1
    - at: [ 0x110, 0x114 ]      # SKNIT irf
      uaddr: SKNIT
      m1_overlap: 1
    - at: 0x10E                 # PUSH V
      uaddr: PUSH_VA
    - at: 0x10F                 # POP V
      uaddr: POP_VA
    - at: 0x11E                 # PUSH B
      uaddr: PUSH_BC
    - at: 0x11F                 # POP B
      uaddr: POP_BC
    - at: 0x12E                 # PUSH D
      uaddr: PUSH_DE
    - at: 0x12F                 # POP D
      uaddr: POP_DE
    - at: 0x13E                 # PUSH H
      uaddr: PUSH_HL
    - at: 0x13F                 # POP H
      uaddr: POP_HL
    - at: 0x120                 # EI
      uaddr: EI
      m1_overlap: 1
    - at: 0x124                 # DI
      uaddr: DI
      m1_overlap: 1
    - at: 0x134                 # SLL A
      uaddr: SLL_A
      m1_overlap: 1
    - at: 0x135                 # SLR A
      uaddr: SLR_A
      m1_overlap: 1

    # 0x2xx: prefix 0x4C

    # 0x3xx: prefix 0x4D
    - at: [ 0x3C0, 0x3FF ]      # MOV sr, A
      uaddr: MOV_SR_A

    # 0x4xx: prefix 0x60
    - at: [ 0x440, 0x447 ]      # ADD r, A
      uaddr: ADD_R_A
      m1_overlap: 1
    - at: [ 0x450, 0x457 ]      # ADC r, A
      uaddr: ADC_R_A
      m1_overlap: 1
    - at: [ 0x460, 0x467 ]      # SUB r, A
      uaddr: SUB_R_A
      m1_overlap: 1
    - at: [ 0x470, 0x477 ]      # SBB r, A
      uaddr: SBB_R_A
      m1_overlap: 1
    - at: [ 0x4c0, 0x4c7 ]      # ADD A, r
      uaddr: ADD_A_R
      m1_overlap: 1

    # 0x5xx: prefix 0x64
    - at: [ 0x520, 0x527 ]      # ADINC r, byte
      uaddr: ADDNC_R_IMM
      skipn: 1
    - at: [ 0x530, 0x537 ]      # SUINB r, byte
      uaddr: SUBNB_R_IMM
      skipn: 1
    - at: [ 0x540, 0x547 ]      # ADI r, byte
      uaddr: ADD_R_IMM
      skipn: 1
    - at: [ 0x548, 0x54f ]      # ONI r, byte
      uaddr: ON_R_IMM
      skipn: 1
    - at: [ 0x550, 0x557 ]      # ACI r, byte
      uaddr: ADC_R_IMM
      skipn: 1
    - at: [ 0x558, 0x55f ]      # OFFI r, byte
      uaddr: OFF_R_IMM
      skipn: 1
    - at: [ 0x560, 0x567 ]      # SUI r, byte
      uaddr: SUB_R_IMM
      skipn: 1
    - at: [ 0x588, 0x58f ]      # ANI sr2, byte
      uaddr: AND_SR_IMM
      skipn: 1
    - at: [ 0x590, 0x597 ]      # XRI sr2, byte
      uaddr: XOR_SR_IMM
      skipn: 1
    - at: [ 0x598, 0x59f ]      # ORI sr2, byte
      uaddr: OR_SR_IMM
      skipn: 1
    - at: [ 0x5c8, 0x5cf ]      # ONI sr2, byte
      uaddr: ON_SR_IMM
      skipn: 1
    - at: [ 0x5d8, 0x5df ]      # OFFI sr2, byte
      uaddr: OFF_SR_IMM
      skipn: 1

    # 0x6xx: prefix 0x70
    - at: [ 0x668, 0x66f ]      # MOV r, word
      uaddr: MOV_ABS
      skipn: 2

    # 0x7xx: prefix 0x74
    - at: 0x7C0                 # ADDW wa
      uaddr: ADDW
      skipn: 1

######################################################################
# Microcode ROM
# Lists nanocode addresses for each step of every instruction
urom:
  columns:
    - name: naddr
      type: e_naddr
      desc: nanocode address
    - name: bm
      type: e_ubm
      desc: branch mode
    - name: m1
      width: 1
      desc: Fetch next opcode (start M1)

  rows:
    - uaddr: IDLE
      naddr: IDLE
      bm: END

      # Idle cycles for skipping instructions w/ 1-2 operands
    - uaddr: SKIP_OP2
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: IDLE
    - uaddr: SKIP_OP1
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: DI
      naddr: DI_C1_T1
      bm: END

    - uaddr: EI
      naddr: EI_C1_T1
      bm: END

    - uaddr: JR
      naddr: JR_C1_T1
    - naddr: JR_C1_T2
    - naddr: JR_C1_T3
    - naddr: JR_C2_T1
    - naddr: JR_C2_T2
    - naddr: JR_C2_T3
    - naddr: JR_C3_T1
    - naddr: JR_C3_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: JRE
      naddr: PC_OUT_INC_T1      # Fetch jdisp
    - naddr: JRE_C1_T2
    - naddr: JRE_C1_T3
    - naddr: JRE_C2_T1
    - naddr: JRE_C2_T2
    - naddr: JRE_C2_T3
      m1: 1
      bm: END

    - uaddr: LDX_IMM_SP
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_SP_C1_T3
    - naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_SP_C2_T3
      m1: 1
      bm: END

    - uaddr: LDX_IMM_B
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_B_C1_T3
    - naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_B_C2_T3
      m1: 1
      bm: END

    - uaddr: LDX_IMM_D
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_D_C1_T3
    - naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_D_C2_T3
      m1: 1
      bm: END

    - uaddr: LDX_IMM_H
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_H_C1_T3
    - naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: LDX_IMM_H_C2_T3
      m1: 1
      bm: END

    - uaddr: DCR
      naddr: DCR_C1_T1
    - naddr: DCR_C1_T2
      bm: END

    - uaddr: MOV_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_IR210_T3
      m1: 1
      bm: END

      # MVIW wa, imm (Move Immediate to Working Register)
    - uaddr: MOVW_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_CO_T3
    - naddr: STORE_CO_TO_VW_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: MOV_SR_A
      naddr: MOV_SR_A_C1_T1
    - naddr: IDLE
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: STAX_D
      naddr: STAX_D_C1_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: STAX_H
      naddr: STAX_H_C1_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: STAX_DP
      naddr: STAX_DP_C1_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: STAX_HP
      naddr: STAX_HP_C1_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: LDW_A
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: LOAD_FROM_VW_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_A_T3
      m1: 1
      bm: END

    - uaddr: LDX_A_H
      naddr: STAX_H_C1_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_A_T3
      m1: 1
      bm: END

    - uaddr: LDX_A_HP
      naddr: STAX_HP_C1_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_A_T3
      m1: 1
      bm: END

    - uaddr: STAW
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: STORE_A_TO_VW_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: ADD_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: ADD_AI_TO_DB       # DB -> idb -> BI, AI + BI -> CO
      m1: 1
    - naddr: ADD_R_WRITEBACK
      bm: END

    - uaddr: ADDNC_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: ADD_AI_TO_DB
      m1: 1
    - naddr: ADDNC_R_IMM_WRITEBACK
      bm: END

    - uaddr: ADC_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: ADC_IMM_C1_T3
      m1: 1
    - naddr: ADD_R_WRITEBACK
      bm: END

    - uaddr: SUBNB_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: SUB_IMM_C1_T3
      m1: 1
    - naddr: SUBNB_R_IMM_WRITEBACK
      bm: END

    - uaddr: SUB_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: SUB_IMM_C1_T3
      m1: 1
    - naddr: SUB_R_IMM_WRITEBACK
      bm: END

    - uaddr: ON_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: OFF_R_IMM_C1_T3
      m1: 1
    - naddr: ON_SR_IMM_C4_T1
      bm: END

    - uaddr: OFF_R_IMM
      naddr: ADD_R_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: OFF_R_IMM_C1_T3
      m1: 1
    - naddr: OFF_SR_IMM_C4_T1
      bm: END

    - uaddr: AND_SR_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: OR_SR_IMM_C1_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OR_SR_IMM_C2_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: AND_SR_IMM_C3_T3
    - naddr: OR_SR_IMM_C4_T1
    - naddr: IDLE
    - naddr: OR_SR_IMM_C4_T3
      m1: 1
      bm: END

    - uaddr: XOR_SR_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: OR_SR_IMM_C1_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OR_SR_IMM_C2_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: XOR_SR_IMM_C3_T3
    - naddr: OR_SR_IMM_C4_T1
    - naddr: IDLE
    - naddr: OR_SR_IMM_C4_T3
      m1: 1
      bm: END

    - uaddr: OR_SR_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: OR_SR_IMM_C1_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OR_SR_IMM_C2_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OR_SR_IMM_C3_T3
    - naddr: OR_SR_IMM_C4_T1
    - naddr: IDLE
    - naddr: OR_SR_IMM_C4_T3
      m1: 1
      bm: END

    - uaddr: ON_SR_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: OR_SR_IMM_C1_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OR_SR_IMM_C2_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: AND_SR_IMM_C3_T3
      m1: 1
    - naddr: ON_SR_IMM_C4_T1
      bm: END

    - uaddr: OFF_SR_IMM
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: OR_SR_IMM_C1_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OR_SR_IMM_C2_T3
    - naddr: IDLE
    - naddr: IDLE
    - naddr: OFF_SR_IMM_C3_T3
      m1: 1
    - naddr: OFF_SR_IMM_C4_T1
      bm: END

    - uaddr: BLOCK
      naddr: BLOCK_C1_T1
    - naddr: BLOCK_C1_T2
    - naddr: BLOCK_C1_T3
    - naddr: BLOCK_C2_T1
    - naddr: BLOCK_C2_T2
    - naddr: BLOCK_C2_T3
    - naddr: BLOCK_C3_T1
    - naddr: BLOCK_C3_T2
    - naddr: BLOCK_C3_T3
      m1: 1
      bm: END

    - uaddr: JMP
      naddr: PC_OUT_INC_T1      # Fetch word lo
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: JMP_C2_T1          # Fetch word hi
    - naddr: JMP_C2_T2
    - naddr: JMP_C2_T3
      m1: 1
      bm: END

      # MOV r, word (Move Memory to Register)
    - uaddr: MOV_ABS
      naddr: PC_OUT_INC_T1      # Fetch word lo
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: PC_OUT_INC_T1      # Fetch word hi
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_CO_T3
    - naddr: MOV_ABS_C3_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_IR210_T3
      m1: 1
      bm: END

      # NEI A, byte (Not Equal Immediate with A)
    - uaddr: NE_A_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: NE_A_IMM_C1_T2
    - naddr: NE_A_IMM_C1_T3
      m1: 1
    - naddr: NE_A_IMM_C2_T1
      bm: END

      # EQI A, byte (Equal Immediate with A)
    - uaddr: EQ_A_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: NE_A_IMM_C1_T2
    - naddr: NE_A_IMM_C1_T3
      m1: 1
    - naddr: EQ_A_IMM_C2_T1
      bm: END

      # GTI A, byte (Greater Than Immediate)
    - uaddr: GT_A_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: NE_A_IMM_C1_T2
    - naddr: GT_A_IMM_C1_T3
      m1: 1
    - naddr: GT_A_IMM_C2_T1
      bm: END

      # LTI A, byte (Less Than Immediate)
    - uaddr: LT_A_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: NE_A_IMM_C1_T2
    - naddr: NE_A_IMM_C1_T3
      m1: 1
    - naddr: LT_A_IMM_C2_T1
      bm: END

      # MVIX rpa1, byte (Move Imm. to Memory naddress by Reg Pair)
    - uaddr: MOVX_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: MOVX_IMM_C2_T1
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

      # CALT (Call Table naddress)
    - uaddr: CALT
      naddr: IDLE               # SP <- SP-1
    - naddr: IDLE
    - naddr: DEC_SP
    - naddr: CALT_C2_T1         # (SP) <- PCH, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: CALT_C3_T1         # (SP) <- PCL
    - naddr: STORE_T2
    - naddr: CALT_C3_T3
    - naddr: CALT_C4_T1         # PCL <- (128 + 2ta)
    - naddr: CALT_C4_T2
    - naddr: CALT_C4_T3
    - naddr: CALT_C5_T1         # PCH <- (129 + 2ta)
    - naddr: CALT_C5_T2
    - naddr: CALT_C5_T3
      m1: 1
      bm: END

      # RET (Return from subroutine)
    - uaddr: RET
      naddr: RET_T1             # PCL <- (SP), SP <- SP+1
    - naddr: RET_T2
    - naddr: RET_C1_T3
    - naddr: RET_T1             # PCH <- (SP), SP <- SP+1
    - naddr: RET_T2
    - naddr: RET_C2_T3
      m1: 1
      bm: END

      # INT (Software/Hardware Interrupt) [19 states]
    - uaddr: INT
      naddr: IDLE               # SP <- SP-1
    - naddr: IDLE
    - naddr: DEC_SP
    - naddr: INT_C2_T1          # (SP) <- PSW, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: CALT_C2_T1         # (SP) <- PCH, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: CALT_C3_T1         # (SP) <- PCL
    - naddr: STORE_T2
    - naddr: CALT_C3_T3
    - naddr: INT_C4_T1          # PCL <- 'h60
    - naddr: IDLE
    - naddr: IDLE
    - naddr: INT_C5_T1          # PCH <- 0
    - naddr: IDLE
    - naddr: IDLE
      m1: 1
      bm: END

      # RETI (Return from Interrupt)
      # Note: Data sheet says 15 cycles, but I think that's a typo.
    - uaddr: RETI
      naddr: RET_T1             # PCL <- (SP), SP <- SP+1
    - naddr: RET_T2
    - naddr: RET_C1_T3
    - naddr: RET_T1             # PCH <- (SP), SP <- SP+1
    - naddr: RET_T2
    - naddr: RET_C2_T3
    - naddr: RET_T1             # PSW <- (SP), SP <- SP+1
    - naddr: RET_T2
    - naddr: RETI_C3_T3
      m1: 1
      bm: END

      # PUSH (Push Register Pair on Stack)
    - uaddr: PUSH_VA
      naddr: IDLE               # SP <- SP-1
    - naddr: IDLE
    - naddr: DEC_SP
    - naddr: PUSH_VA_C2_T1      # (SP) <- V, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: PUSH_VA_C3_T1      # (SP) <- A
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: PUSH_BC
      naddr: IDLE               # SP <- SP-1
    - naddr: IDLE
    - naddr: DEC_SP
    - naddr: PUSH_BC_C2_T1      # (SP) <- B, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: PUSH_BC_C3_T1      # (SP) <- C
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: PUSH_DE
      naddr: IDLE               # SP <- SP-1
    - naddr: IDLE
    - naddr: DEC_SP
    - naddr: PUSH_DE_C2_T1      # (SP) <- D, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: PUSH_DE_C3_T1      # (SP) <- E
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

    - uaddr: PUSH_HL
      naddr: IDLE               # SP <- SP-1
    - naddr: IDLE
    - naddr: DEC_SP
    - naddr: PUSH_HL_C2_T1      # (SP) <- H, SP <- SP-1
    - naddr: STORE_T2
    - naddr: DEC_SP
    - naddr: PUSH_HL_C3_T1      # (SP) <- L
    - naddr: STORE_T2
    - naddr: IDLE
      m1: 1
      bm: END

      # POP (Pop Register Pair from Stack)
    - uaddr: POP_VA
      naddr: POP_T1             # (SP) <- A, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_VA_C1_T3
    - naddr: POP_T1             # (SP) <- V, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_VA_C2_T3
      m1: 1
      bm: END

    - uaddr: POP_BC
      naddr: POP_T1             # (SP) <- C, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_BC_C1_T3
    - naddr: POP_T1             # (SP) <- B, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_BC_C2_T3
      m1: 1
      bm: END

    - uaddr: POP_DE
      naddr: POP_T1             # (SP) <- E, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_DE_C1_T3
    - naddr: POP_T1             # (SP) <- D, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_DE_C2_T3
      m1: 1
      bm: END

    - uaddr: POP_HL
      naddr: POP_T1             # (SP) <- L, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_HL_C1_T3
    - naddr: POP_T1             # (SP) <- H, SP <- SP+1
    - naddr: LOAD_T2
    - naddr: POP_HL_C2_T3
      m1: 1
      bm: END

      # SKIT irf (Skip If Interrupt)
    - uaddr: SKIT
      naddr: SKIT_C1_T1
      bm: END

      # SKNIT irf (Skip If No Interrupt)
    - uaddr: SKNIT
      naddr: SKNIT_C1_T1
      bm: END

      # STM (Start Timer)
    - uaddr: STM
      # TODO
      bm: END

      # INRW wa (Increment Working Register)
    - uaddr: INRW
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: INRW_C2_T1         # VW -> ab -> aor
    - naddr: LOAD_T2
    - naddr: INRW_C2_T3         # DB -> idb -> AI, AI + 1 -> CO
    - naddr: STORE_CO_TO_VW_T1
    - naddr: STORE_T2
    - naddr: INRW_C4_T3         # Update PSW.Z,SK,HC
      m1: 1
      bm: END

      # INR r2 (Increment Register)
    - uaddr: INR
      naddr: INR_C1_T1
    - naddr: INR_C1_T2
      bm: END

      # ONI A, byte (On-Test Immediate with A)
    - uaddr: ON_A_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: NE_A_IMM_C1_T2
    - naddr: ON_A_IMM_C1_T3
      m1: 1
    - naddr: ON_SR_IMM_C4_T1
      bm: END

      # OFFI A, byte (Off-Test Immediate with A)
    - uaddr: OFF_A_IMM
      naddr: PC_OUT_INC_T1      # Fetch byte
    - naddr: NE_A_IMM_C1_T2
    - naddr: OFF_A_IMM_C1_T3
      m1: 1
    - naddr: OFF_SR_IMM_C4_T1
      bm: END

      # MOV A, r1 (Move Register to A)
    - uaddr: MOV_A_R1
      naddr: MOV_A_R1_C1_T1
      bm: END

      # MOV r1, A (Move A to Register)
    - uaddr: MOV_R1_A
      naddr: MOV_R1_A_C1_T1
      bm: END
      
      # SLL A (Shift Logical Left A)
    - uaddr: SLL_A
      naddr: SLL_A_C1_T1
    - naddr: SLL_A_C1_T2
      bm: END
      
      # SLR A (Shift Logical Right A)
    - uaddr: SLR_A
      naddr: SLR_A_C1_T1
    - naddr: SLL_A_C1_T2
      bm: END

    - uaddr: ADD_A_IMM
      naddr: ADD_A_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: ADD_AI_TO_DB
      m1: 1
    - naddr: ADD_A_WRITEBACK    # CO -> A, Update PSW.Z,CY,HC
      bm: END

    - uaddr: ADDNC_A_IMM
      naddr: ADD_A_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: ADD_AI_TO_DB
      m1: 1
    - naddr: ADDNC_A_IMM_WRITEBACK
      bm: END

    - uaddr: SUBNB_A_IMM
      naddr: ADD_A_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: SUB_IMM_C1_T3
      m1: 1
    - naddr: SUBNB_A_IMM_WRITEBACK
      bm: END

    - uaddr: SUB_A_IMM
      naddr: ADD_A_IMM_C1_T1
    - naddr: LOAD_T2
    - naddr: SUB_IMM_C1_T3
      m1: 1
    - naddr: SUB_A_IMM_WRITEBACK
      bm: END

    - uaddr: ADD_R_A
      naddr: WRITE_R_TO_AI
    - naddr: ADD_R_A_C1_T2
    - naddr: ADD_R_WRITEBACK
      bm: END

    - uaddr: ADC_R_A
      naddr: WRITE_R_TO_AI
    - naddr: ADC_R_A_C1_T2
    - naddr: ADD_R_WRITEBACK
      bm: END

    - uaddr: SUB_R_A
      naddr: WRITE_R_TO_AI
    - naddr: SUB_R_A_C1_T2
    - naddr: ADD_R_WRITEBACK
      bm: END

    - uaddr: SBB_R_A
      naddr: WRITE_R_TO_AI
    - naddr: SBB_R_A_C1_T2
    - naddr: ADD_R_WRITEBACK
      bm: END

      # ADD A, r (Add Register to A)
    - uaddr: ADD_A_R
      naddr: WRITE_A_TO_AI
    - naddr: ADD_A_R_C1_T2
    - naddr: ADD_A_WRITEBACK
      bm: END

      # DCRW wa (Decrement Working Register)
    - uaddr: DCRW
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: INRW_C2_T1         # VW -> ab -> aor
    - naddr: LOAD_T2
    - naddr: DCRW_C2_T3         # DB -> idb -> AI, AI - 1 -> CO
    - naddr: STORE_CO_TO_VW_T1
    - naddr: STORE_T2
    - naddr: INRW_C4_T3         # Update PSW.Z,SK,HC
      m1: 1
      bm: END

      # ADDW wa (Add Working Register to A)
    - uaddr: ADDW
      naddr: PC_OUT_INC_T1
    - naddr: LOAD_T2
    - naddr: WRITE_DB_TO_W_T3
    - naddr: ADDW_C2_T1         # VW -> ab -> aor, A -> AI
    - naddr: LOAD_T2
    - naddr: ADD_AI_TO_DB       # DB -> idb -> BI, AI + BI -> CO
      m1: 1
    - naddr: ADD_A_WRITEBACK    # CO -> A, Update PSW.Z,CY,HC
      bm: END


######################################################################
# Nanocode ROM
nrom:
  columns:
    - name: idx
      width: 3
      desc: general-purpose data
    - name: rfos
      type: e_urfs
      desc: register file output select -> idb
    - name: rfts
      type: e_urfs
      desc: register file target select
    - name: idbs
      type: e_idbs
      desc: idb select
    - name: lts
      type: e_lts
      desc: load target select
    - name: abs
      type: e_abs
      desc: ab select
    - name: abits
      type: e_abs
      desc: abi target select
    - name: pc_inc
      width: 1
      desc: increment PC
    - name: ab_inc
      width: 1
      desc: increment ab
    - name: ab_dec
      width: 1
      desc: decrement ab
    - name: aout
      width: 1
      desc: ab -> AOR
    - name: load
      width: 1
      desc: assert RDB (read operation)
    - name: store
      width: 1
      desc: dor -> DB
    - name: aluop
      type: e_aluop
      desc: ALU operation
    - name: cis
      type: e_cis
      desc: ALU carry in select
    - name: bi0
      width: 1
      desc: Zero BI
    - name: bin
      width: 1
      desc: Negate BI
    - name: pswz
      width: 1
      desc: (CO == 0) -> PSW.Z
    - name: pswcy
      width: 1
      desc: CCO -> PSW.CY
    - name: pswhc
      width: 1
      desc: CHO -> PSW.HC
    - name: pswsk
      type: e_sks
      desc: PSW.SK source
    - name: sprs
      type: e_sprs
      desc: special register select
    - name: sdgs
      type: e_sdgs
      desc: special data generator select
  
  
  rows:
    - naddr: IDLE
  
    - naddr: PC_OUT_INC_T1
      aout: 1
      pc_inc: 1
    - naddr: LOAD_T2
      load: 1
    - naddr: STORE_T2
      # dor -> DB
      store: 1
  
    - naddr: DI_C1_T1           # DI
      idx: 0
      lts: IE
  
    - naddr: EI_C1_T1           # EI
      idx: 1
      lts: IE
  
    - naddr: JR_C1_T1           # JR (Jump relative)
      # PCL -> idb -> AI
      rfos: PCL
      idbs: RF
      lts: AI
    - naddr: JR_C1_T2
      # IR[5:0] -> idb -> BI
      idbs: SDG
      sdgs: JRL
      lts: BI
    - naddr: JR_C1_T3
      # AI + BI -> CO
      aluop: SUM
      cis: 0
    - naddr: JR_C2_T1
      # CO -> idb -> PCL
      idbs: CO
      lts: RF
      rfts: PCL
    - naddr: JR_C2_T2
      # PCH -> idb -> AI
      rfos: PCH
      idbs: RF
      lts: AI
    - naddr: JR_C2_T3
      # sign-ext. IR[5] -> idb -> BI
      idbs: SDG
      sdgs: JRH
      lts: BI
    - naddr: JR_C3_T1
      # AI + BI + CCO -> CO
      aluop: SUM
      cis: CCO
    - naddr: JR_C3_T2
      # CO -> idb -> PCH
      idbs: CO
      lts: RF
      rfts: PCH
  
    - naddr: JRE_C1_T2          # JRE +jdisp
      # PCL -> idb -> AI
      rfos: PCL
      idbs: RF
      lts: AI
      load: 1
    - naddr: JRE_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI + BI -> CO
      aluop: SUM
      cis: 0
    - naddr: JRE_C2_T1
      # CO -> idb -> PCL
      idbs: CO
      lts: RF
      rfts: PCL
    - naddr: JRE_C2_T2
      # PCH -> idb -> AI, 0 -> BI
      rfos: PCH
      idbs: RF
      lts: AI
      bi0: 1
      # AI + BI + CCO -> CO
      aluop: SUM
      cis: CCO
    - naddr: JRE_C2_T3
      # CO -> idb -> PCH
      idbs: CO
      lts: RF
      rfts: PCH
  
    - naddr: LDX_IMM_SP_C1_T3   # LXI SP, bbaa
      # DB -> idb -> SPL
      idbs: DB
      rfts: SPL
      lts: RF
    - naddr: LDX_IMM_SP_C2_T3
      # DB -> idb -> SPH
      idbs: DB
      rfts: SPH
      lts: RF
  
    - naddr: LDX_IMM_B_C1_T3    # LXI BC, bbaa
      # DB -> idb -> C
      idbs: DB
      rfts: C
      lts: RF
    - naddr: LDX_IMM_B_C2_T3
      # DB -> idb -> B
      idbs: DB
      rfts: B
      lts: RF
  
    - naddr: LDX_IMM_D_C1_T3    # LXI DE, bbaa
      # DB -> idb -> E
      idbs: DB
      rfts: E
      lts: RF
    - naddr: LDX_IMM_D_C2_T3
      # DB -> idb -> D
      idbs: DB
      rfts: D
      lts: RF
  
    - naddr: LDX_IMM_H_C1_T3    # LXI HL, bbaa
      # DB -> idb -> L
      idbs: DB
      rfts: L
      lts: RF
    - naddr: LDX_IMM_H_C2_T3
      # DB -> idb -> H
      idbs: DB
      rfts: H
      lts: RF
  
    - naddr: INR_C1_T1          # INR r2
      # r2 -> idb -> AI, AI + 1 -> CO
      rfos: IR210
      idbs: RF
      lts: AI
      aluop: INC
    - naddr: INR_C1_T2
      # CO -> idb -> r2
      rfts: IR210
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswhc: 1                  # Update PSW.HC
      pswsk: C                  # CCO -> PSW.SK
  
    - naddr: DCR_C1_T1          # DCR r2
      # r2 -> idb -> AI, AI - 1 -> CO
      rfos: IR210
      idbs: RF
      lts: AI
      aluop: DEC
    - naddr: DCR_C1_T2
      # CO -> idb -> r2
      rfts: IR210
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswhc: 1                  # Update PSW.HC
      pswsk: NC                 # !CCO -> PSW.SK
  
    - naddr: WRITE_DB_TO_IR210_T3
      # DB -> idb -> r
      idbs: DB
      rfts: IR210
      lts: RF
  
    - naddr: MOV_SR_A_C1_T1     # MOV sr, A
      # A -> idb -> spr
      rfos: A
      idbs: RF
      lts: SPR
      sprs: IR3
  
    - naddr: STAX_D_C1_T1       # STAX D
      # DE -> ab -> aor
      abs: DE
      aout: 1
      # A -> idb -> dor
      rfos: A
      idbs: RF
      lts: DOR
  
    - naddr: STAX_H_C1_T1       # STAX H
      # HL -> ab -> aor
      abs: HL
      aout: 1
      # A -> idb -> dor
      rfos: A
      idbs: RF
      lts: DOR
  
    - naddr: STAX_DP_C1_T1      # STAX D+
      # DE -> ab -> aor
      abs: DE
      aout: 1
      # A -> idb -> dor
      rfos: A
      idbs: RF
      lts: DOR
      # DE + 1 -> DE
      ab_inc: 1
      abits: DE
  
    - naddr: STAX_HP_C1_T1      # STAX H+
      # HL -> ab -> aor
      abs: HL
      aout: 1
      # A -> idb -> dor
      rfos: A
      idbs: RF
      lts: DOR
      # HL + 1 -> HL
      ab_inc: 1
      abits: HL
  
    - naddr: STORE_A_TO_VW_T1
      # A -> idb -> dor
      rfos: A
      idbs: RF
      lts: DOR
      # VW -> ab -> aor
      abs: VW
      aout: 1
  
    - naddr: INRW_C2_T1
      # VW -> ab -> aor
      abs: VW
      aout: 1
    - naddr: INRW_C2_T3
      # DB -> idb -> AI
      idbs: DB
      lts: AI
      # AI + 1 -> CO
      aluop: INC
    - naddr: STORE_CO_TO_VW_T1
      # CO -> idb -> dor
      idbs: CO
      lts: DOR
      # VW -> ab -> aor
      abs: VW
      aout: 1
    - naddr: INRW_C4_T3
      pswz: 1                   # Update PSW.Z
      pswhc: 1                  # Update PSW.HC
      pswsk: C                  # CCO -> PSW.SK
  
      # ADI r, byte (Add Immediate to Register)
    - naddr: ADD_R_IMM_C1_T1
      # PC -> ab -> aor, PC+1 -> PC
      aout: 1
      pc_inc: 1
      # r -> idb -> AI
      rfos: IR210
      idbs: RF
      lts: AI
    - naddr: ADD_AI_TO_DB
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI + BI -> CO
      aluop: SUM
    - naddr: ADD_R_WRITEBACK
      # CO -> idb -> r
      rfts: IR210
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC

      # ADINC r, byte (Add Immediate to Register. Skip if No Carry)
    - naddr: ADDNC_R_IMM_WRITEBACK
      # CO -> idb -> r
      rfts: IR210
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: NC                 # !CCO -> PSW.SK

      # ACI r, byte (Add Immediate to Register with Carry)
    - naddr: ADC_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI + BI + PSW.CY -> CO
      aluop: SUM
      cis: PSW_CY

      # SUI r, byte (Subtract Immediate from Register)
    - naddr: SUB_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI - BI -> CO
      aluop: SUM
      bin: 1
      cis: 1
    - naddr: SUB_R_IMM_WRITEBACK
      # CO -> idb -> r
      rfts: IR210
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC

      # SUINB r, byte (Subtract Immediate from Register. Skip if No Borrow)
    - naddr: SUBNB_R_IMM_WRITEBACK
      # CO -> idb -> r
      rfts: IR210
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: C                  # CCO -> PSW.SK

      # OFFI r, byte (Off-Test Immediate with Register)
    - naddr: OFF_R_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI & BI -> CO
      aluop: AND

    - naddr: OR_SR_IMM_C1_T3    # ORI sr2, byte
      # DB -> idb -> BI
      idbs: DB
      lts: BI
    - naddr: OR_SR_IMM_C2_T3
      # spr -> idb -> AI
      sprs: IR2
      idbs: SPR
      lts: AI
    - naddr: OR_SR_IMM_C3_T3
      # AI | BI -> CO
      aluop: OR
    - naddr: OR_SR_IMM_C4_T1
      pswz: 1                   # Update PSW.Z
    - naddr: OR_SR_IMM_C4_T3
      # CO -> idb -> spr
      idbs: CO
      lts: SPR
      sprs: IR2
  
    - naddr: AND_SR_IMM_C3_T3   # ANI sr2, byte
      # AI & BI -> CO
      aluop: AND

    - naddr: XOR_SR_IMM_C3_T3   # XRI sr2, byte
      # AI ^ BI -> CO
      aluop: EOR

    - naddr: OFF_SR_IMM_C3_T3  # OFFI sr2, byte
      # AI & ~BI -> CO
      aluop: AND
      bin: 1
    - naddr: OFF_SR_IMM_C4_T1
      pswz: 1                   # Update PSW.Z
      pswsk: Z                  # (CO == 0) -> PSW.SK

    - naddr: ON_SR_IMM_C4_T1    # ONI sr2, byte
      pswz: 1                   # Update PSW.Z
      pswsk: NZ                 # (CO != 0) -> PSW.SK
  
      # BLOCK: (DE)+ <- (HL)+, C <- C - 1, end if borrow
    - naddr: BLOCK_C1_T1
      # HL -> ab -> aor
      abs: HL
      aout: 1
    - naddr: BLOCK_C1_T2
      # HL + 1 -> HL
      abs: HL
      ab_inc: 1
      abits: HL
      load: 1
    - naddr: BLOCK_C1_T3
      # DB -> idb -> W
      idbs: DB
      rfts: W
      lts: RF
    - naddr: BLOCK_C2_T1
      # W -> idb -> dor
      rfos: W
      idbs: RF
      lts: DOR
      # DE -> ab -> aor
      abs: DE
      aout: 1
    - naddr: BLOCK_C2_T2
      # dor -> DB
      store: 1
      # DE + 1 -> DE
      abs: DE
      ab_inc: 1
      abits: DE
    - naddr: BLOCK_C2_T3
    - naddr: BLOCK_C3_T1
      # C -> idb -> AI, AI - 1 -> CO
      rfos: C
      idbs: RF
      lts: AI
      aluop: DEC
    - naddr: BLOCK_C3_T2
      # CO -> idb -> C
      rfts: C
      idbs: CO
      lts: RF
    - naddr: BLOCK_C3_T3
      pswsk: NC                 # !CCO -> PSW.SK
      abs: PC
      ab_dec: 1                 # repeat ins. until skipped
  
    - naddr: WRITE_DB_TO_W_T3
      # DB -> idb -> W
      idbs: DB
      rfts: W
      lts: RF
    - naddr: JMP_C2_T1
      # Fetch word hi
      aout: 1
    - naddr: JMP_C2_T2
      # W -> idb -> PCL
      rfos: W
      idbs: RF
      lts: RF
      rfts: PCL
      load: 1
    - naddr: JMP_C2_T3
      # DB -> idb -> PCH
      idbs: DB
      lts: RF
      rfts: PCH
  
    - naddr: WRITE_DB_TO_CO_T3
      # DB -> idb -> AI, 0 -> BI
      idbs: DB
      lts: AI
      bi0: 1
      # AI + BI -> CO
      aluop: SUM
    - naddr: MOV_ABS_C3_T1
      # W -> abl -> aorl, CO -> idb -> abh -> aorh
      idbs: CO
      abs: IDB_W
      aout: 1
  
      # NEI A, byte (Not Equal Immediate with A)
    - naddr: NE_A_IMM_C1_T2
      # A -> idb -> AI
      rfos: A
      idbs: RF
      lts: AI
      load: 1
    - naddr: NE_A_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI - BI -> CO
      aluop: SUM
      bin: 1
      cis: 1
    - naddr: NE_A_IMM_C2_T1
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: NZ                 # Update PSW.SK
  
      # EQI A, byte (Equal Immediate with A)
    - naddr: EQ_A_IMM_C2_T1
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: Z                  # Update PSW.SK

      # GTI A, byte (Greater Than Immediate)
    - naddr: GT_A_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI - BI - 1 -> CO
      aluop: SUM
      bin: 1
    - naddr: GT_A_IMM_C2_T1
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: C                  # Update PSW.SK

      # LTI A, byte (Less Than Immediate)
    - naddr: LT_A_IMM_C2_T1
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: NC                 # Update PSW.SK

      # MVIX rpa1, byte (Move Imm. to Memory naddress by Reg Pair)
    - naddr: MOVX_IMM_C2_T1
      # W -> idb -> dor
      rfos: W
      idbs: RF
      lts: DOR
      # DE -> ab -> aor
      abs: IR10
      aout: 1
  
      # CALT (Call Table naddress)
    - naddr: CALT_C1_T1         # SP <- SP-1
      at: [ 0x80, 0xBF ]
      # IR[5:0] -> idb -> AI
      idbs: SDG
      sdgs: JRL
      lts: AI
    - naddr: DEC_SP
      # SP - 1 -> SP
      abs: SP
      ab_dec: 1
      abits: SP
    - naddr: CALT_C2_T1         # (SP) <- PCH, SP <- SP-1
      # PCH -> idb -> dor
      rfos: PCH
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: CALT_C3_T1         # (SP) <- PCL
      # PCL -> idb -> dor
      rfos: PCL
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: CALT_C3_T3
      # effective naddr lo. -> idb -> W
      idx: 0
      idbs: SDG
      sdgs: CALT
      lts: RF
      rfts: W
    - naddr: CALT_C4_T1          # PCL <- (128 + 2ta)
      # W -> abl -> aorl, 0 -> idb -> abh -> aorh
      idbs: 0
      abs: IDB_W
      aout: 1
    - naddr: CALT_C4_T2
      load: 1
      # effective naddr hi. -> idb -> W
      idx: 1
      idbs: SDG
      sdgs: CALT
      lts: RF
      rfts: W
    - naddr: CALT_C4_T3
      # DB -> idb -> PCL
      idbs: DB
      lts: RF
      rfts: PCL
    - naddr: CALT_C5_T1          # PCH <- (129 + 2ta)
      # W -> abl -> aorl, 0 -> idb -> abh -> aorh
      idbs: 0
      abs: IDB_W
      aout: 1
    - naddr: CALT_C5_T2
      load: 1
    - naddr: CALT_C5_T3
      # DB -> idb -> PCH
      idbs: DB
      lts: RF
      rfts: PCH
  
      # RET (Return from subroutine)
    - naddr: RET_T1
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: RET_T2
      load: 1
      # SP + 1 -> SP
      abs: SP
      ab_inc: 1
      abits: SP
    - naddr: RET_C1_T3
      # DB -> idb -> PCL
      idbs: DB
      lts: RF
      rfts: PCL
    - naddr: RET_C2_T3
      # DB -> idb -> PCL
      idbs: DB
      lts: RF
      rfts: PCH

      # INT (Software/Hardware Interrupt)
    - naddr: INT_C2_T1          # (SP) <- PSW
      # PSW -> idb -> dor
      rfos: PSW
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: INT_C4_T1          # 0 -> idb -> PCH
      idbs: 0
      lts: RF
      rfts: PCH
    - naddr: INT_C5_T1          # intva -> idb -> PCL
      sdgs: INTVA
      idbs: SDG
      lts: RF
      rfts: PCL

      # RETI (Return from Interrupt)
    - naddr: RETI_C3_T3
      # DB -> idb -> PSW
      idbs: DB
      lts: RF
      rfts: PSW

      # PUSH (Push Register Pair on Stack)
    - naddr: PUSH_VA_C2_T1      # (SP) <- V, SP <- SP-1
      # V -> idb -> dor
      rfos: V
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_VA_C3_T1      # (SP) <- A
      # A -> idb -> dor
      rfos: A
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_BC_C2_T1      # (SP) <- B, SP <- SP-1
      # B -> idb -> dor
      rfos: B
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_BC_C3_T1      # (SP) <- C
      # C -> idb -> dor
      rfos: C
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_DE_C2_T1      # (SP) <- D, SP <- SP-1
      # D -> idb -> dor
      rfos: D
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_DE_C3_T1      # (SP) <- E
      # E -> idb -> dor
      rfos: E
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_HL_C2_T1      # (SP) <- H, SP <- SP-1
      # H -> idb -> dor
      rfos: H
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1
    - naddr: PUSH_HL_C3_T1      # (SP) <- L
      # L -> idb -> dor
      rfos: L
      idbs: RF
      lts: DOR
      # SP -> ab -> aor
      abs: SP
      aout: 1

      # POP (Pop Register Pair from Stack)
    - naddr: POP_T1
      # SP -> ab -> aor
      abs: SP
      aout: 1
      # SP + 1 -> SP
      ab_inc: 1
      abits: SP
    - naddr: POP_VA_C1_T3
      # DB -> idb -> A
      idbs: DB
      lts: RF
      rfts: A
    - naddr: POP_VA_C2_T3
      # DB -> idb -> V
      idbs: DB
      lts: RF
      rfts: V
    - naddr: POP_BC_C1_T3
      # DB -> idb -> C
      idbs: DB
      lts: RF
      rfts: C
    - naddr: POP_BC_C2_T3
      # DB -> idb -> B
      idbs: DB
      lts: RF
      rfts: B
    - naddr: POP_DE_C1_T3
      # DB -> idb -> E
      idbs: DB
      lts: RF
      rfts: E
    - naddr: POP_DE_C2_T3
      # DB -> idb -> D
      idbs: DB
      lts: RF
      rfts: D
    - naddr: POP_HL_C1_T3
      # DB -> idb -> L
      idbs: DB
      lts: RF
      rfts: L
    - naddr: POP_HL_C2_T3
      # DB -> idb -> H
      idbs: DB
      lts: RF
      rfts: H

      # SKIT irf (Skip If Interrupt)
    - naddr: SKIT_C1_T1
      pswsk: I                  # irf -> PSW.SK

      # SKNIT irf (Skip If No Interrupt)
    - naddr: SKNIT_C1_T1
      pswsk: NI                 # !irf -> PSW.SK

    - naddr: LOAD_FROM_VW_T1
      # VW -> ab -> aor
      abs: VW
      aout: 1
    - naddr: WRITE_DB_TO_A_T3
      # DB -> idb -> A
      idbs: DB
      rfts: A
      lts: RF

      # ONI A, byte (On-Test Immediate with A)
    - naddr: ON_A_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI & BI -> CO
      aluop: AND

      # OFFI A, byte (Off-Test Immediate with A)
    - naddr: OFF_A_IMM_C1_T3
      # DB -> idb -> BI
      idbs: DB
      lts: BI
      # AI & ~BI -> CO
      aluop: AND
      bin: 1

      # MOV A, r1 (Move Register to A)
    - naddr: MOV_A_R1_C1_T1
      # A -> idb -> r1
      rfos: IR210
      idbs: RF
      rfts: A
      lts: RF

      # MOV r1, A (Move A to Register)
    - naddr: MOV_R1_A_C1_T1
      # r1 -> idb -> A
      rfos: A
      idbs: RF
      rfts: IR210
      lts: RF

    - naddr: SLL_A_C1_T1        # SLL A
      # r2 -> idb -> AI, AI << 1 -> CO
      rfos: A
      idbs: RF
      lts: AI
      aluop: LSL
    - naddr: SLL_A_C1_T2
      # CO -> idb -> A
      rfts: A
      idbs: CO
      lts: RF
      pswcy: 1                  # Update PSW.CY

    - naddr: SLR_A_C1_T1        # SLR A
      # r2 -> idb -> AI, AI >> 1 -> CO
      rfos: A
      idbs: RF
      lts: AI
      aluop: LSR
  
      # ADI A, byte (Add Immediate to A)
    - naddr: ADD_A_IMM_C1_T1
      # PC -> ab -> aor, PC+1 -> PC
      aout: 1
      pc_inc: 1
      # A -> idb -> AI
      rfos: A
      idbs: RF
      lts: AI
    - naddr: ADD_A_WRITEBACK
      # CO -> idb -> A
      rfts: A
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC

      # ADINC A, byte (Add Immediate to A. Skip if No Carry)
    - naddr: ADDNC_A_IMM_WRITEBACK
      # CO -> idb -> A
      rfts: A
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: NC                 # !CCO -> PSW.SK

      # SUI A, byte (Subtract Immediate from A)
    - naddr: SUB_A_IMM_WRITEBACK
      # CO -> idb -> A
      rfts: A
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC

      # SUINB A, byte (Subtract Immediate from A. Skip if No Borrow)
    - naddr: SUBNB_A_IMM_WRITEBACK
      # CO -> idb -> A
      rfts: A
      idbs: CO
      lts: RF
      pswz: 1                   # Update PSW.Z
      pswcy: 1                  # Update PSW.CY
      pswhc: 1                  # Update PSW.HC
      pswsk: C                  # CCO -> PSW.SK

      # ADD r, A (Add A to Register)
    - naddr: WRITE_R_TO_AI
      # r -> idb -> AI
      rfos: IR210
      idbs: RF
      lts: AI
    - naddr: ADD_R_A_C1_T2
      # A -> idb -> BI
      rfos: A
      idbs: RF
      lts: BI
      # AI + BI -> CO
      aluop: SUM

      # ADC r, A (Add A to Register with Carry)
    - naddr: ADC_R_A_C1_T2
      # A -> idb -> BI
      rfos: A
      idbs: RF
      lts: BI
      # AI + BI + PSW.CY -> CO
      aluop: SUM
      cis: PSW_CY

      # SUB r, A (Subtract A from Register)
    - naddr: SUB_R_A_C1_T2
      # A -> idb -> BI
      rfos: A
      idbs: RF
      lts: BI
      # AI - BI -> CO
      aluop: SUM
      bin: 1
      cis: 1

      # SBB r, A (Subtract A from Register with Borrow)
    - naddr: SBB_R_A_C1_T2
      # A -> idb -> BI
      rfos: A
      idbs: RF
      lts: BI
      # AI - BI - 1 -> CO
      aluop: SUM
      bin: 1

      # DCRW wa (Decrement Working Register)
    - naddr: DCRW_C2_T3
      # DB -> idb -> AI
      idbs: DB
      lts: AI
      # AI - 1 -> CO
      aluop: DEC

      # ADDW wa (Add Working Register to A)
    - naddr: ADDW_C2_T1
      # VW -> ab -> aor
      abs: VW
      aout: 1
      # A -> idb -> AI
      rfos: A
      idbs: RF
      lts: AI

      # ADD A, r (Add Register to A)
    - naddr: WRITE_A_TO_AI
      # A -> idb -> AI
      rfos: A
      idbs: RF
      lts: AI
    - naddr: ADD_A_R_C1_T2
      # r -> idb -> BI
      rfos: IR210
      idbs: RF
      lts: BI
      # AI + BI -> CO
      aluop: SUM

